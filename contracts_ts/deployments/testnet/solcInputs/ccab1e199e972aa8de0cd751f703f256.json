{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/abstracts/OnlyRoleStatus.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.20;\r\n\r\nimport { MsgSender, RoleBased } from \"../implementations/RoleBased.sol\";\r\nimport { IRoleBased } from \"../interfaces/IRoleBased.sol\";\r\n\r\nabstract contract OnlyRoleStatus is MsgSender {\r\n    address public roleManager;\r\n\r\n    constructor(address _roleManager)\r\n    {\r\n        _setRoleManager(_roleManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Caller must have owner role before execeution can proceed.\r\n     * The 'errorMessage' argument can be used to return error specific to \r\n     * a context e.g function call. \r\n     * @param errorMessage : Custom error message\r\n     */\r\n    modifier onlyRoleStatus(string memory errorMessage) {\r\n        address mgr = roleManager;\r\n        require(mgr != address(0), \"OnlyRoleStatus: Manager not set\");\r\n        require(IRoleBased(mgr).hasRole(_msgSender()), errorMessage);\r\n        _;\r\n    }\r\n\r\n    function _setRoleManager(\r\n        address newManager\r\n    )\r\n        private\r\n    {\r\n        roleManager = newManager;\r\n    }\r\n\r\n    /**\r\n     * Set RoleManager\r\n     * @param newManager : New manager address\r\n     */\r\n    function setRoleManager(\r\n        address newManager\r\n    )\r\n        public\r\n        onlyRoleStatus(\"OnlyRoleStatus: Not permitted\")\r\n        returns(bool)\r\n    {\r\n        _setRoleManager(newManager);\r\n        return true;\r\n    }\r\n}"
    },
    "contracts/abstracts/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.20;\r\n\r\nimport { OnlyRoleStatus } from \"./OnlyRoleStatus.sol\";\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n * \r\n * We use part of the Openzeppelin Pausable contract to supplement our strategy.\r\n * Thanks to the OZ team.\r\n */\r\nabstract contract Pausable is OnlyRoleStatus {\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is paused.\r\n     */\r\n    error EnforcedPause();\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is not paused.\r\n     */\r\n    error ExpectedPause();\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor(\r\n        address _roleManager\r\n    ) OnlyRoleStatus(_roleManager) {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view {\r\n        if (paused()) {\r\n            revert EnforcedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        if (!paused()) {\r\n            revert ExpectedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     * Only owner role can call.\r\n     * - The contract must not be paused.\r\n     */\r\n    function pause() \r\n        public \r\n        onlyRoleStatus(\"Pausable: OnlyRoleStatus can pause\") \r\n        whenNotPaused \r\n    {\r\n        _paused = true; \r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     * - Only owner role can call.\r\n     * - The contract must be paused.\r\n     */\r\n    function unpause() \r\n        public \r\n        onlyRoleStatus(\"Pausable: OnlyRoleStatus can unpause\") \r\n        whenPaused \r\n    {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n"
    },
    "contracts/implementations/BuyerV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IFactory } from \"../interfaces/IFactory.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { Lib } from \"../Lib.sol\";\r\nimport { Common } from \"./Common.sol\";\r\nimport { IBuyer } from \"../interfaces/IBuyer.sol\";\r\n\r\ncontract BuyerV1 is Common, IBuyer {\r\n    using Lib for *;\r\n\r\n    // Errors\r\n    error QuantityShouldBeGreaterThanZero(uint8);\r\n    error CallerNotTheCustomer(address);\r\n    error TransferCommitmentFailed();\r\n    error OrderAlreadyCancelled(uint);\r\n    error QuantityCannotBeZero(uint24);\r\n    error RequestedQuantityExceedAvailableQuantity(uint24 requested, uint24 expected);\r\n\r\n    // Platform fee in %\r\n    uint8 public feePercentage;\r\n\r\n    /**\r\n     * @notice Contract identifier\r\n     * We use it to identify which contract is calling in the factory contract.\r\n     */\r\n    bytes32 immutable interfaceId;\r\n\r\n    constructor(\r\n        IFactory _factory, \r\n        IERC20 _uSDT, \r\n        address _roleBasedManager\r\n    ) \r\n        Common(_factory, _uSDT, _roleBasedManager) \r\n    {\r\n        feePercentage = 50; // 0.05%\r\n        interfaceId = keccak256(abi.encodePacked(\"BUYER\"));\r\n    }\r\n\r\n    /** ------> PUBLIC FUNCTIONS <-------  */\r\n\r\n    function setFeePercentage(uint8 newFeePercentage) public onlyRoleStatus(\"Buyer: Not the owner\") returns (bool) {\r\n        feePercentage = newFeePercentage;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Buyer makes order for a specific good item showing they're interest indeed.\r\n     * Note: Buyers maintain an internal wallet created automatically for them on signUp.\r\n     * Buyer should give approval to spend before executing this function.\r\n     * @param itemId : Item Id.\r\n     * @param requestedQuantity : Quantity of item user wants to negotiate for.\r\n     * @param offerPrice: The Price buyer is willing to pay per unit of listed item.\r\n     * @param  destinationAddr: Address where item should be dispatched if order goes well.\r\n     * @param contact: Buyer's contract i.e phone/email. Can be concatenate.\r\n     * \r\n     * Note: While placing order, the buyer make commitment in full amount of the weighted offerPrice and qty.\r\n     */\r\n    function startOrder(\r\n        uint24 requestedQuantity,\r\n        uint itemId,\r\n        uint offerPrice,\r\n        string memory destinationAddr,\r\n        string memory contact\r\n    ) \r\n        public \r\n        validateIds(itemId, 0, false)\r\n    {\r\n        (uint allowance, uint24 initialQty) = _initialCheck(_wrappedFactory().getItem(itemId), _msgSender(), requestedQuantity, offerPrice);\r\n        unchecked {\r\n            _wrappedFactory().placeOrder(\r\n                IFactory.Order(\r\n                    requestedQuantity, \r\n                    uint32(block.timestamp), \r\n                    offerPrice, \r\n                    allowance,\r\n                    _msgSender(), \r\n                    IFactory.Stage.COMMIT,\r\n                    IFactory.Info(destinationAddr.toBytes(), contact.toBytes()),\r\n                    address(0)\r\n                ), \r\n                itemId,\r\n                initialQty - requestedQuantity\r\n            );\r\n        }\r\n        if(!IERC20(uSDT).transferFrom(_msgSender(), address(this), allowance)) revert TransferCommitmentFailed();\r\n    }\r\n\r\n    /**\r\n     * @dev Edit order.\r\n     * @param newQuantity : New quantity.\r\n     * @param itemId: Item index.\r\n     * @param newOfferPrice : New offer price.\r\n     * @param orderId : Position of order in the list/Order index.\r\n     */\r\n    function editOrder(\r\n        uint24 newQuantity,\r\n        uint itemId,\r\n        uint newOfferPrice,\r\n        uint orderId\r\n    ) \r\n        public\r\n        validateIds(itemId, orderId, true)\r\n        returns(bool)\r\n    {\r\n        (IFactory.Item memory item, IFactory iFact) = _requireIsABuyer(itemId, orderId, _msgSender());\r\n        _checkOrderStage(item, orderId);\r\n        (uint allowance,) = _initialCheck(item, _msgSender(), newQuantity, newOfferPrice);\r\n        iFact.editOrder(newQuantity, itemId, orderId, newOfferPrice, allowance);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Buyer cancels order.\r\n     * @param itemId: Item index.\r\n     * @param orderId : Position of order in the list/Order index.\r\n     */\r\n    function cancelOrder(\r\n        uint itemId,\r\n        uint orderId\r\n    ) \r\n        public\r\n        validateIds(itemId, orderId, true)\r\n        returns(bool)\r\n    {\r\n        (IFactory.Item memory item, IFactory iFact) = _requireIsABuyer(itemId, orderId, _msgSender());\r\n        if(item.info.orders[orderId].stage == IFactory.Stage.CANCELLED) revert OrderAlreadyCancelled(orderId);\r\n        _checkOrderStage(item, orderId);\r\n        return iFact.cancelOrder(itemId, orderId);\r\n    }\r\n\r\n\r\n    /** ------> INTERNAL FUNCTIONS <-------  */\r\n\r\n    function _requireIsABuyer(\r\n        uint itemId, \r\n        uint negoId, \r\n        address caller\r\n    ) \r\n        internal \r\n        view\r\n        returns(IFactory.Item memory item, IFactory iFact) \r\n    {\r\n        iFact = _wrappedFactory();\r\n        item = iFact.getItem(itemId);\r\n        if(item.info.orders[negoId].customer != caller) {\r\n            revert CallerNotTheCustomer(caller);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev For buyer to interact with an order, the order stage must be in any of the following:\r\n     *      - COMMIT, or\r\n     *      - REJECTED, or\r\n     *      - CANCELLED\r\n     * @param orderId : Order Id.\r\n     * @param item : item data\r\n     */\r\n    function _checkOrderStage(IFactory.Item memory item, uint orderId) internal pure {\r\n        require(uint8(item.info.orders[orderId].stage) < 3, \"Cannot cancel order at this time\");\r\n    }\r\n\r\n    function _initialCheck(\r\n        IFactory.Item memory item,\r\n        address buyer, \r\n        uint24 requestedQuantity, \r\n        uint offerPrice\r\n    ) \r\n        internal \r\n        view\r\n        returns(uint allowance, uint24 initialQty) \r\n    {\r\n        allowance = IERC20(uSDT).allowance(buyer, address(this));\r\n        if(requestedQuantity == 0) revert QuantityCannotBeZero(requestedQuantity);\r\n        if(requestedQuantity > item.info.quantity) revert RequestedQuantityExceedAvailableQuantity(requestedQuantity, uint24(item.info.quantity));\r\n        initialQty = uint24(item.info.quantity);\r\n        require(allowance >= offerPrice * requestedQuantity, \"Factory: Allowance too low\");\r\n    }\r\n\r\n    function _deductFee(\r\n        uint amount, \r\n        address feeReceiver\r\n    ) \r\n        internal \r\n        returns(uint balance) \r\n    {\r\n        uint fee = amount.computeFee(feePercentage);\r\n        unchecked {\r\n            balance = amount - fee;\r\n        }\r\n        if(fee > 0) {\r\n            _transferFee(fee, feeReceiver);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Refunds Buyer their commitment. This happens when Sellers wish to remove their ADs\r\n     * @param orders : Order struct data. See IFactory.Order.\r\n     */\r\n    function refund(\r\n        IFactory.Order[] memory orders\r\n    ) \r\n        external \r\n        onlyRoleStatus(\"Buyer: Only Seller contract is allowed\")\r\n        returns(bool)\r\n    {\r\n        for(uint i = 0; i < orders.length; i++) {\r\n            if(orders[i].commitment > 0) {\r\n                require(orders[i].stage == IFactory.Stage.COMMIT || orders[i].stage == IFactory.Stage.REJECTED, \"Buyer: Blocked\");\r\n                approve(orders[i].customer, orders[i].commitment);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Buyer pays seller. \r\n     * @notice Fee is deducted.\r\n     * @param amount : Amount to pay.\r\n     * @param seller : Seller's address.\r\n     */\r\n    function paySeller(\r\n        uint amount, \r\n        address seller, \r\n        address feeReceiver\r\n    ) \r\n        external \r\n        onlyRoleStatus(\"Buyer: Only Factory is allowed\")\r\n        returns(bool)\r\n    {\r\n        approve(seller, _deductFee(amount, feeReceiver));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Buyer confirm receipt of goods. On confirmation, the trade is finalized \r\n     * and payment is released to the seller.\r\n     * @param itemId : Item Id.\r\n     * @param orderId : Order Id.\r\n     */\r\n    function confirmOnReceipt(\r\n        uint itemId,\r\n        uint orderId\r\n    ) \r\n        public \r\n        validateIds(itemId, orderId, true)\r\n        returns(bool) \r\n    {\r\n        (, IFactory iFact) = _requireIsABuyer(itemId, orderId, _msgSender());\r\n        iFact.signConfirmation(itemId, orderId, _msgSender());\r\n\r\n        return true;\r\n    }\r\n\r\n    function getInterfaceId() external view returns(bytes32) {\r\n        return interfaceId;\r\n    }\r\n}"
    },
    "contracts/implementations/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IFactory } from \"../interfaces/IFactory.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { Lib } from \"../Lib.sol\";\r\nimport { Pausable } from \"../abstracts/Pausable.sol\";\r\n\r\nabstract contract Common is Pausable {\r\n    using Lib for *;\r\n\r\n    // Errors\r\n    error UnsupportedCategory(uint8);\r\n    error InvalidItemId(uint);\r\n\r\n    IFactory immutable factory;\r\n    IERC20 public uSDT;\r\n\r\n    /**\r\n     * @notice In order to use 'categorySelector' with the enum Category, we must\r\n     * ensure 'categorySelector' is not out of bound since enums are index based\r\n     * just like an array. \r\n     * @param categorySelector : Category selector \r\n     */\r\n    modifier validateCategoryId(uint8 categorySelector) {\r\n        if(categorySelector >= 10) revert UnsupportedCategory(categorySelector);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function : Validate store Id\r\n     * @param itemId : Item id\r\n     * @param orderId : Order id\r\n     * @param includeOrderId : Boolean flag to validate order id or not.\r\n    */\r\n    modifier validateIds(\r\n        uint itemId, \r\n        uint orderId, \r\n        bool includeOrderId\r\n    ) \r\n    {\r\n        if(itemId >= _wrappedFactory().getStoreSize()) revert InvalidItemId(itemId);\r\n        if(includeOrderId) {\r\n            orderId.assertLThan(_wrappedFactory().getItem(itemId).info.orders.length, \"Invalid orderId\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        IFactory _factory,\r\n        IERC20 _uSDT, \r\n        address _roleManager\r\n    ) \r\n        Pausable(_roleManager)\r\n    {\r\n        address(_factory).notEqualInAddress(address(0), \"_factory is undefined\");\r\n        factory = _factory;\r\n        uSDT = _uSDT;\r\n    }\r\n\r\n    function _wrappedFactory() internal view returns(IFactory iFactory) {\r\n        iFactory = IFactory(factory);\r\n    } \r\n\r\n    function approve(address to, uint amt) internal {\r\n        IERC20(uSDT).approve(to, amt);\r\n    } \r\n\r\n    /**\r\n     * @dev Transfer fee to fee receiver\r\n     * @param amount : Amount to send.\r\n     * @param feeReceiver : Recipient.\r\n     */\r\n    function _transferFee(uint amount, address feeReceiver) internal {\r\n        IERC20(uSDT).transfer(feeReceiver, amount);\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/implementations/RoleBased.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.20;\r\n\r\nimport { IRoleBased } from \"../interfaces/IRoleBased.sol\";\r\n/**\r\n * @title MsgSender \r\n * @author (Bobeu)\r\n * @notice Non-deployable contract simply returning the calling account.\r\n */\r\nabstract contract MsgSender {\r\n    function _msgSender() internal view returns(address sender) {\r\n        sender = msg.sender;\r\n    }\r\n}\r\n\r\n/**\r\n * @title RoleBased \r\n * @author (Bobeu)\r\n * @notice Standalone contract for managing roleship in kimiko protocol.\r\n */\r\ncontract RoleBased is IRoleBased, MsgSender{\r\n    /**\r\n     * @notice Number of roles.\r\n     */\r\n    uint public rolesCount;\r\n\r\n    /**\r\n     * @notice Addresses with roleship permission.\r\n     */\r\n    \r\n    mapping (address => bool) private _isRoleBased;\r\n\r\n    /**\r\n     * @notice Mapping of rolesCount to addresses.\r\n     * A valid id will return a mapped role.\r\n     */\r\n    mapping (uint => address) public roles;\r\n\r\n    /**\r\n     * @dev Only role is allowed.\r\n     */\r\n    modifier onlyRoleStatus {\r\n        require(_isRoleBased[_msgSender()], \"Oop! Caller is not recognized\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        _setRole(_msgSender(), true);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns role variable.\r\n     */\r\n    function _getRole(uint roleId) \r\n        internal \r\n        view \r\n        returns(address _role) \r\n    {\r\n        _role = roles[roleId];\r\n    }\r\n\r\n    /**\r\n     * @dev Add or remove target address as role.\r\n     * @param target: Target address.\r\n     * @notice 'target' parameter must not be empty.\r\n     */\r\n    function _setRole(\r\n        address target,\r\n        bool add\r\n    ) \r\n        private \r\n    {\r\n        require(target != address(0), \"Simplifi RoleBased: 'target' parameter is empty\");\r\n        add? (_isRoleBased[target] = true, rolesCount ++) : (_isRoleBased[target] = false, rolesCount --);\r\n    }\r\n\r\n    /**\r\n     * @dev Add a new role address\r\n     * @param newRoles: New roles\r\n     * @notice Only address with role permission can add another role.\r\n     */\r\n    function setPermission(\r\n        address[] memory newRoles\r\n    ) \r\n        external\r\n        onlyRoleStatus\r\n        returns(bool) \r\n    {\r\n        bool rt = true;\r\n        for(uint r = 0; r < newRoles.length; r++) {\r\n            _setRole(newRoles[r], rt);\r\n        }\r\n        return rt;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an address as role.\r\n     * @param target: Target address\r\n     * @notice Only address with role permission can remove another role.\r\n     */\r\n    function removeRole(\r\n        address target\r\n    ) \r\n        external\r\n        onlyRoleStatus\r\n        returns(bool) \r\n    {\r\n        _setRole(target, false);\r\n        return true;\r\n    }\r\n    /**\r\n     * @dev An role can renounce their roleship. This however will not leave the\r\n     * contract empty without an role. There must be at least one role left.\r\n     * @notice Only address with role permission can renounce roleship.\r\n     */\r\n    function renounceRole() \r\n        external\r\n        onlyRoleStatus\r\n        returns(bool) \r\n    {\r\n        require(rolesCount > 1, \"At least 2 roles is required for one to leave\"); \r\n        _setRole(_msgSender(), false);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns role variable.\r\n     * Can be called externally by contracts.\r\n     * @param roleId : Owner Id. \r\n     */\r\n    function getRole(\r\n        uint roleId\r\n    ) \r\n        external \r\n        view \r\n        returns(address) \r\n    {\r\n        return _getRole(roleId);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if target is an role.\r\n     * @param target : Target address.\r\n     */\r\n    function hasRole(\r\n        address target\r\n    )\r\n        external\r\n        view \r\n        returns(bool) \r\n    {\r\n        return _isRoleBased[target];\r\n    }\r\n}"
    },
    "contracts/interfaces/IBuyer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { IFactory } from \"./IFactory.sol\";\r\nimport { ICommon } from \"./ICommon.sol\";\r\n\r\ninterface IBuyer is ICommon {\r\n    function refund(IFactory.Order[] memory) external returns(bool);\r\n    function paySeller(uint amount, address seller, address feeReceiver) external returns(bool);\r\n}"
    },
    "contracts/interfaces/ICommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface ICommon {\r\n    function getInterfaceId() external view returns(bytes32);\r\n}"
    },
    "contracts/interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IFactory {\r\n    enum Category { FASHION, ELECTRONICS, PHONESNTABLETS, FURNITURES, VEHICLES, ANIMALSNPETS, EQUIPMENTSNTOOLS, REPAIRNCONSTRUCTION, SOFTWARES, BABIESNKIDS }\r\n    enum Stage { COMMIT, ACCEPTED, REJECTED, CANCELLED, INTRANSIT, DELIVERED }\r\n\r\n    error UnsupportedCategory(uint8);\r\n    error InvalidItemId();\r\n    error InvalidOrderId(uint negoId);\r\n    error OnlyBuyerCanConfirmDelivery();\r\n    error NotTheRealNegotiator(address);\r\n    error RequestedQuantityExceedAvailableQuantity(uint requested, uint expected);\r\n\r\n    struct Item {\r\n        address seller;\r\n        ItemInfo info;\r\n        ItemMetadata meta;\r\n    }\r\n\r\n    struct ItemInfo {\r\n        uint quantity;\r\n        uint id;\r\n        uint priceLimit;\r\n        bytes description;\r\n        bytes location;\r\n        Order[] orders;\r\n    }\r\n\r\n    struct ItemMetadata {\r\n        Category category;\r\n        bytes uri;\r\n    }\r\n\r\n    struct Order {\r\n        uint24 quantity;\r\n        uint32 date;\r\n        uint offerPrice;\r\n        uint commitment;\r\n        address customer;\r\n        Stage stage;\r\n        Info info;\r\n        address firstSigner;\r\n    }\r\n\r\n    struct Info {\r\n        bytes destination;\r\n        bytes contacts;\r\n    }\r\n\r\n    // -------> PARAMS <-------\r\n\r\n    struct AddItemParam {\r\n        uint8 quantity;\r\n        uint8 categorySelector;\r\n        uint priceLimit;\r\n        string imageUrI;\r\n        string description;\r\n        string location;\r\n        address seller;\r\n    }\r\n\r\n    function listNewItem(AddItemParam memory) external returns(Item memory) ;\r\n    function placeOrder(Order memory order, uint itemId, uint24 newQuantity) external returns(bool);\r\n    function getItem(uint itemId) external view returns(Item memory);\r\n    function editPriceLimit(uint itemId, uint newPriceLimit) external returns (bool);\r\n    function editOrder(\r\n        uint24 newQuantity,\r\n        uint itemId,\r\n        uint orderId,\r\n        uint newOfferPrice,\r\n        uint newCommitment\r\n    )\r\n        external\r\n        returns(bool);\r\n\r\n    function editQuantity(uint24 newQuantity, uint itemId) external returns (bool);\r\n    function getStoreSize() external view returns(uint);\r\n    function removeItem(uint itemId) external returns(bool);\r\n    function cancelOrder(uint itemId, uint orderId) external returns(bool);\r\n    function signConfirmation(uint itemId, uint orderId, address party) external returns(bool);\r\n    function moveOrder(\r\n        uint itemId,\r\n        uint orderId,\r\n        Stage stage\r\n    ) external returns(bool);\r\n\r\n    event ItemRemoved(uint itemId, IERC20 asset);\r\n}"
    },
    "contracts/interfaces/IRoleBased.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.20;\r\n\r\n/**\r\n * @title IRoleBased \r\n * Interface of the RoleBased contract\r\n * @author Bobeu\r\n */\r\ninterface IRoleBased {\r\n    function setPermission(\r\n        address[] memory newRoles\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function removeRole(\r\n        address target\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function renounceRole() \r\n        external\r\n        returns(bool);\r\n\r\n    function getRole(\r\n        uint ownerId\r\n    ) \r\n        external \r\n        view \r\n        returns(address);\r\n\r\n    function hasRole(\r\n        address target\r\n    )\r\n        external\r\n        view \r\n        returns(bool);\r\n}"
    },
    "contracts/Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nlibrary Lib {\r\n    function isZeroAddress(address target) internal pure returns(bool _isZero) {\r\n        _isZero = target == address(0);\r\n    }\r\n\r\n    function notEqualInAddress(address a, address b, string memory errorMessage) internal pure {\r\n        require( a != b, errorMessage);\r\n    }\r\n\r\n    function equalInAddress(address a, address b, string memory errorMessage)internal pure {\r\n        require( a == b, errorMessage);\r\n    }\r\n\r\n    function assertEqual(uint a, uint b, string memory errorMessage) internal pure {\r\n        require( a == b, errorMessage);\r\n    }\r\n\r\n    function assertGThan(uint a, uint b, string memory errorMessage) internal pure {\r\n        require( a > b, errorMessage);\r\n    }\r\n\r\n    function assertLThan(uint a, uint b, string memory errorMessage) internal pure {\r\n        require( a < b, errorMessage);\r\n    }\r\n\r\n    function assertGThanOrEqual(uint a, uint b, string memory errorMessage) internal pure {\r\n        require( a >= b, errorMessage);\r\n    }\r\n\r\n    function toBytes(string memory str) internal pure returns(bytes memory) {\r\n        return abi.encode(str);\r\n    }\r\n\r\n    /**\r\n     * Percentage base\r\n     */\r\n    function _getBase() internal pure returns(uint16 base) {\r\n        base = 10000;\r\n    }\r\n\r\n    /**\r\n        @dev Computes platform fee.\r\n        @param makerRate : The amount of fee (in %) charged by the platform\r\n            Note : Raw rate must multiply by 100 to get the expected value i.e\r\n            if maker rate is 0.1%, it should be parsed as 0.1 * 100 = 10.\r\n            See `_getPercentage()`.\r\n        @param amount should be in decimals.\r\n    */\r\n    function computeFee(\r\n        uint amount, \r\n        uint16 makerRate\r\n    ) \r\n        internal \r\n        pure \r\n        returns (uint mFee) \r\n    {\r\n        mFee = _getPercentage(amount, makerRate);\r\n    }\r\n\r\n    /**     @dev Calculation of percentage.\r\n        *   This is how we calculate percentage to arrive at expected value with \r\n        *   good precision.\r\n        *   We chose a base value (numerator as 10000) repesenting a 100% of input value. This means if Alice wish to set \r\n        *   her interest rate to 0.05%, she only need to multiply it by 100 i.e 0.05 * 100 = 5. Her input will be 5. \r\n        *   Since Solidity do not accept decimals as input, in our context, the minimum value to parse is '0' indicating \r\n        *   zero interest rate. If the platform wish to set interest at least, the minimum value will be 1 reprensenting 0.01%.\r\n        *   The minimum interest rate to set is 0.01% if interest must be set at least.\r\n        *   @notice To reiterate, raw interest must be multiplied by 100 before giving as input. \r\n        *   @param principal : The principal value on which the interest is based. Value should be in decimals.\r\n        *   @param interest : Interest rate. \r\n        *   \r\n        *   Rules\r\n        *   -----\r\n        *   - Principal cannot be less than base.\r\n        *   - Interest cannot be greater than (2 ^ 16) - 1\r\n    */\r\n    function _getPercentage(\r\n        uint principal, \r\n        uint16 interest\r\n    )\r\n        internal \r\n        pure \r\n        returns (uint _return) \r\n    {\r\n        uint16 base = _getBase(); \r\n        if(interest == 0 || principal == 0) return 0;\r\n        assertLThan(interest, type(uint16).max, \"Interest overflow\");\r\n        assertGThan(principal, base, \"Principal should be greater than 10000\");\r\n        unchecked {\r\n            _return = (principal * interest) / base;\r\n        }\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "byzantium",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}