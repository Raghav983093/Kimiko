{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/abstracts/OnlyRoleStatus.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.20;\r\n\r\nimport { MsgSender, RoleBased } from \"../implementations/RoleBased.sol\";\r\nimport { IRoleBased } from \"../interfaces/IRoleBased.sol\";\r\n\r\nabstract contract OnlyRoleStatus is MsgSender {\r\n    address public roleManager;\r\n\r\n    constructor(address _roleManager)\r\n    {\r\n        _setRoleManager(_roleManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Caller must have owner role before execeution can proceed.\r\n     * The 'errorMessage' argument can be used to return error specific to \r\n     * a context e.g function call. \r\n     * @param errorMessage : Custom error message\r\n     */\r\n    modifier onlyRoleStatus(string memory errorMessage) {\r\n        address mgr = roleManager;\r\n        require(mgr != address(0), \"OnlyRoleStatus: Manager not set\");\r\n        require(IRoleBased(mgr).hasRole(_msgSender()), errorMessage);\r\n        _;\r\n    }\r\n\r\n    function _setRoleManager(\r\n        address newManager\r\n    )\r\n        private\r\n    {\r\n        roleManager = newManager;\r\n    }\r\n\r\n    /**\r\n     * Set RoleManager\r\n     * @param newManager : New manager address\r\n     */\r\n    function setRoleManager(\r\n        address newManager\r\n    )\r\n        public\r\n        onlyRoleStatus(\"OnlyRoleStatus: Not permitted\")\r\n        returns(bool)\r\n    {\r\n        _setRoleManager(newManager);\r\n        return true;\r\n    }\r\n}"
    },
    "contracts/abstracts/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.20;\r\n\r\nimport { OnlyRoleStatus } from \"./OnlyRoleStatus.sol\";\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n * \r\n * We use part of the Openzeppelin Pausable contract to supplement our strategy.\r\n * Thanks to the OZ team.\r\n */\r\nabstract contract Pausable is OnlyRoleStatus {\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is paused.\r\n     */\r\n    error EnforcedPause();\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is not paused.\r\n     */\r\n    error ExpectedPause();\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor(\r\n        address _roleManager\r\n    ) OnlyRoleStatus(_roleManager) {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view {\r\n        if (paused()) {\r\n            revert EnforcedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        if (!paused()) {\r\n            revert ExpectedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     * Only owner role can call.\r\n     * - The contract must not be paused.\r\n     */\r\n    function pause() \r\n        public \r\n        onlyRoleStatus(\"Pausable: OnlyRoleStatus can pause\") \r\n        whenNotPaused \r\n    {\r\n        _paused = true; \r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     * - Only owner role can call.\r\n     * - The contract must be paused.\r\n     */\r\n    function unpause() \r\n        public \r\n        onlyRoleStatus(\"Pausable: OnlyRoleStatus can unpause\") \r\n        whenPaused \r\n    {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n"
    },
    "contracts/FeeReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract FeeReceiver is Ownable {\r\n    constructor () Ownable(_msgSender()) {}\r\n\r\n    function withdraw(uint amount, address to, address asset) public onlyOwner returns(bool) {\r\n        return IERC20(asset).transfer(to, amount);\r\n    }\r\n}"
    },
    "contracts/implementations/BuyerV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IFactory } from \"../interfaces/IFactory.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { Lib } from \"../Lib.sol\";\r\nimport { Common } from \"./Common.sol\";\r\nimport { IBuyer } from \"../interfaces/IBuyer.sol\";\r\n\r\ncontract BuyerV1 is Common, IBuyer {\r\n    using Lib for *;\r\n\r\n    // Errors\r\n    error QuantityShouldBeGreaterThanZero(uint8);\r\n    error CallerNotTheCustomer(address);\r\n    error TransferCommitmentFailed();\r\n    error QuantityCannotBeZero(uint24);\r\n    error RequestedQuantityExceedAvailableQuantity(uint24 requested, uint24 expected);\r\n\r\n    // Platform fee in %\r\n    uint8 public feePercentage;\r\n\r\n    /**\r\n     * @notice Contract identifier\r\n     * We use it to identify which contract is calling in the factory contract.\r\n     */\r\n    bytes32 immutable interfaceId;\r\n\r\n    constructor(\r\n        IFactory _factory, \r\n        IERC20 _uSDT, \r\n        address _roleBasedManager\r\n    ) \r\n        Common(_factory, _uSDT, _roleBasedManager) \r\n    {\r\n        feePercentage = 50; // 0.05%\r\n        interfaceId = keccak256(abi.encodePacked(\"BUYER\"));\r\n    }\r\n\r\n    /** ------> PUBLIC FUNCTIONS <-------  */\r\n\r\n    function setFeePercentage(uint8 newFeePercentage) public onlyRoleStatus(\"Buyer: Not the owner\") returns (bool) {\r\n        feePercentage = newFeePercentage;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Buyer makes order for a specific good item showing they're interest indeed.\r\n     * Note: Buyers maintain an internal wallet created automatically for them on signUp.\r\n     * Buyer should give approval to spend before executing this function.\r\n     * @param itemId : Item Id.\r\n     * @param requestedQuantity : Quantity of item user wants to negotiate for.\r\n     * @param offerPrice: The Price buyer is willing to pay per unit of listed item.\r\n     * @param  destinationAddr: Address where item should be dispatched if order goes well.\r\n     * @param contact: Buyer's contract i.e phone/email. Can be concatenate.\r\n     * \r\n     * Note: While placing order, the buyer make commitment in full amount of the weighted offerPrice and qty.\r\n     */\r\n    function startOrder(\r\n        uint24 requestedQuantity,\r\n        uint itemId,\r\n        uint offerPrice,\r\n        string memory destinationAddr,\r\n        string memory contact\r\n    ) \r\n        public \r\n        validateIds(itemId, 0, false)\r\n    {\r\n        (uint allowance, uint24 initialQty) = _initialCheck(_wrappedFactory().getItem(itemId), _msgSender(), requestedQuantity, offerPrice);\r\n        unchecked {\r\n            _wrappedFactory().placeOrder(\r\n                IFactory.Order(\r\n                    requestedQuantity, \r\n                    uint32(block.timestamp), \r\n                    offerPrice, \r\n                    allowance,\r\n                    _msgSender(), \r\n                    IFactory.Stage.COMMIT,\r\n                    IFactory.Info(destinationAddr.toBytes(), contact.toBytes()),\r\n                    address(0)\r\n                ), \r\n                itemId,\r\n                initialQty - requestedQuantity\r\n            );\r\n        }\r\n        if(!IERC20(uSDT).transferFrom(_msgSender(), address(this), allowance)) revert TransferCommitmentFailed();\r\n    }\r\n\r\n    /**\r\n     * @dev Edit order.\r\n     * @param newQuantity : New quantity.\r\n     * @param itemId: Item index.\r\n     * @param newOfferPrice : New offer price.\r\n     * @param orderId : Position of order in the list/Order index.\r\n     */\r\n    function editOrder(\r\n        uint24 newQuantity,\r\n        uint itemId,\r\n        uint newOfferPrice,\r\n        uint orderId\r\n    ) \r\n        public\r\n        validateIds(itemId, orderId, true)\r\n        returns(bool)\r\n    {\r\n        (IFactory.Item memory item, IFactory iFact) = _requireIsABuyer(itemId, orderId, _msgSender());\r\n        _checkOrderStage(item, orderId);\r\n        (uint allowance,) = _initialCheck(item, _msgSender(), newQuantity, newOfferPrice);\r\n        iFact.editOrder(newQuantity, itemId, orderId, newOfferPrice, allowance);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Buyer cancels order.\r\n     * @param itemId: Item index.\r\n     * @param orderId : Position of order in the list/Order index.\r\n     */\r\n    function cancelOrder(\r\n        uint itemId,\r\n        uint orderId\r\n    ) \r\n        public\r\n        validateIds(itemId, orderId, true)\r\n        returns(bool)\r\n    {\r\n        (IFactory.Item memory item, IFactory iFact) = _requireIsABuyer(itemId, orderId, _msgSender());\r\n        _checkOrderStage(item, orderId);\r\n        return iFact.cancelOrder(itemId, orderId);\r\n    }\r\n\r\n\r\n    /** ------> INTERNAL FUNCTIONS <-------  */\r\n\r\n    function _requireIsABuyer(\r\n        uint itemId, \r\n        uint negoId, \r\n        address caller\r\n    ) \r\n        internal \r\n        view\r\n        returns(IFactory.Item memory item, IFactory iFact) \r\n    {\r\n        iFact = _wrappedFactory();\r\n        item = iFact.getItem(itemId);\r\n        if(item.info.orders[negoId].customer != caller) {\r\n            revert CallerNotTheCustomer(caller);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev For buyer to interact with an order, the order stage must be in any of the following:\r\n     *      - COMMIT, or\r\n     *      - REJECTED, or\r\n     *      - CANCELLED\r\n     * @param orderId : Order Id.\r\n     * @param item : item data\r\n     */\r\n    function _checkOrderStage(IFactory.Item memory item, uint orderId) internal {\r\n        require(uint8(item.info.orders[orderId].stage) < 3, \"Cannot cancel order at this time\");\r\n    }\r\n\r\n    function _initialCheck(\r\n        IFactory.Item memory item,\r\n        address buyer, \r\n        uint24 requestedQuantity, \r\n        uint offerPrice\r\n    ) \r\n        internal \r\n        view\r\n        returns(uint allowance, uint24 initialQty) \r\n    {\r\n        allowance = IERC20(uSDT).allowance(buyer, address(this));\r\n        if(requestedQuantity == 0) revert QuantityCannotBeZero(requestedQuantity);\r\n        if(requestedQuantity > item.info.quantity) revert RequestedQuantityExceedAvailableQuantity(requestedQuantity, uint24(item.info.quantity));\r\n        initialQty = uint24(item.info.quantity);\r\n        require(allowance >= offerPrice * requestedQuantity, \"Factory: Allowance too low\");\r\n    }\r\n\r\n    function _deductFee(\r\n        uint amount, \r\n        address feeReceiver\r\n    ) \r\n        internal \r\n        returns(uint balance) \r\n    {\r\n        uint fee = amount.computeFee(feePercentage);\r\n        unchecked {\r\n            balance = amount - fee;\r\n        }\r\n        if(fee > 0) {\r\n            _transferFee(fee, feeReceiver);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Refunds Buyer their commitment. This happens when Sellers wish to remove their ADs\r\n     * @param orders : Order struct data. See IFactory.Order.\r\n     */\r\n    function refund(\r\n        IFactory.Order[] memory orders\r\n    ) \r\n        external \r\n        onlyRoleStatus(\"Buyer: Only Seller contract is allowed\")\r\n        returns(bool)\r\n    {\r\n        for(uint i = 0; i < orders.length; i++) {\r\n            if(orders[i].commitment > 0) {\r\n                require(orders[i].stage == IFactory.Stage.COMMIT || orders[i].stage == IFactory.Stage.REJECTED, \"Buyer: Blocked\");\r\n                approve(orders[i].customer, orders[i].commitment);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Buyer pays seller. \r\n     * @notice Fee is deducted.\r\n     * @param amount : Amount to pay.\r\n     * @param seller : Seller's address.\r\n     */\r\n    function paySeller(\r\n        uint amount, \r\n        address seller, \r\n        address feeReceiver\r\n    ) \r\n        external \r\n        onlyRoleStatus(\"Buyer: Only Factory is allowed\")\r\n        returns(bool)\r\n    {\r\n        approve(seller, _deductFee(amount, feeReceiver));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Buyer confirm receipt of goods. On confirmation, the trade is finalized \r\n     * and payment is released to the seller.\r\n     * @param itemId : Item Id.\r\n     * @param orderId : Order Id.\r\n     */\r\n    function confirmOnReceipt(\r\n        uint itemId,\r\n        uint orderId\r\n    ) \r\n        public \r\n        validateIds(itemId, orderId, true)\r\n        returns(bool) \r\n    {\r\n        (, IFactory iFact) = _requireIsABuyer(itemId, orderId, _msgSender());\r\n        iFact.signConfirmation(itemId, orderId, _msgSender());\r\n\r\n        return true;\r\n    }\r\n\r\n    function getInterfaceId() external view returns(bytes32) {\r\n        return interfaceId;\r\n    }\r\n}"
    },
    "contracts/implementations/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IFactory } from \"../interfaces/IFactory.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { Lib } from \"../Lib.sol\";\r\nimport { Pausable } from \"../abstracts/Pausable.sol\";\r\n\r\nabstract contract Common is Pausable {\r\n    using Lib for *;\r\n\r\n    // Errors\r\n    error UnsupportedCategory(uint8);\r\n    error InvalidItemId(uint);\r\n\r\n    IFactory immutable factory;\r\n    IERC20 public uSDT;\r\n\r\n    /**\r\n     * @notice In order to use 'categorySelector' with the enum Category, we must\r\n     * ensure 'categorySelector' is not out of bound since enums are index based\r\n     * just like an array. \r\n     * @param categorySelector : Category selector \r\n     */\r\n    modifier validateCategoryId(uint8 categorySelector) {\r\n        if(categorySelector >= 10) revert UnsupportedCategory(categorySelector);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function : Validate store Id\r\n     * @param itemId : Item id\r\n     * @param orderId : Order id\r\n     * @param includeOrderId : Boolean flag to validate order id or not.\r\n    */\r\n    modifier validateIds(\r\n        uint itemId, \r\n        uint orderId, \r\n        bool includeOrderId\r\n    ) \r\n    {\r\n        if(itemId >= _wrappedFactory().getStoreSize()) revert InvalidItemId(itemId);\r\n        if(includeOrderId) {\r\n            orderId.assertLThan(_wrappedFactory().getItem(itemId).info.orders.length, \"Invalid orderId\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        IFactory _factory,\r\n        IERC20 _uSDT, \r\n        address _roleManager\r\n    ) \r\n        Pausable(_roleManager)\r\n    {\r\n        address(_factory).notEqualInAddress(address(0), \"_factory is undefined\");\r\n        factory = _factory;\r\n        uSDT = _uSDT;\r\n    }\r\n\r\n    function _wrappedFactory() internal view returns(IFactory iFactory) {\r\n        iFactory = IFactory(factory);\r\n    } \r\n\r\n    function approve(address to, uint amt) internal {\r\n        IERC20(uSDT).approve(to, amt);\r\n    } \r\n\r\n    /**\r\n     * @dev Transfer fee to fee receiver\r\n     * @param amount : Amount to send.\r\n     * @param feeReceiver : Recipient.\r\n     */\r\n    function _transferFee(uint amount, address feeReceiver) internal {\r\n        IERC20(uSDT).transfer(feeReceiver, amount);\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/implementations/Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IFactory } from \"../interfaces/IFactory.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { Lib } from \"../Lib.sol\";\r\nimport { ICommon } from \"../interfaces/ICommon.sol\";\r\nimport { IBuyer } from \"../interfaces/IBuyer.sol\";\r\nimport { Pausable } from \"../abstracts/Pausable.sol\";\r\n\r\ncontract Factory is IFactory, Pausable {\r\n    using Lib for *;\r\n\r\n    // Stablecoin address\r\n    IERC20 public uSDT;\r\n\r\n    // Fee receiver\r\n    address public feeTo;\r\n\r\n    bytes32 public constant BUYER_ID = keccak256(abi.encodePacked(\"BUYER\"));\r\n    bytes32 public constant SELLER_ID = keccak256(abi.encodePacked(\"SELLER\"));\r\n\r\n    /**\r\n     * @dev Array of storeItems\r\n     * Note: For the purpose of testing and to quickly share data\r\n     * to the frontend, we employ this pattern of storage. As the array \r\n     * grow in size, it may have huge impact on gas cost hence we plan to \r\n     * switch to a more cheaper storage type.\r\n     */ \r\n    Item[] private storeFront;\r\n\r\n    constructor(\r\n        address _feeTo, \r\n        address _roleManager\r\n    ) \r\n        Pausable(_roleManager) \r\n    {\r\n        _feeTo.notEqualInAddress(address(0), \"FeeReceiver is zero address\");\r\n        require(_feeTo != address(0), \"Invalid FeeReceiver\");\r\n        feeTo = _feeTo;\r\n    }\r\n\r\n    // -------> INTERNAL FUNCTIONS <---------\r\n\r\n    /**\r\n     * @dev Only store owner function: Change price limit i.e lower price an item can be sold\r\n     * @param itemId : Required: Item reference Id.\r\n     * @param newQuantity : Required: New available quantity.\r\n    */\r\n    function _editQuantity(\r\n        uint96 newQuantity,\r\n        uint itemId\r\n    ) internal {\r\n        storeFront[itemId].info.quantity = newQuantity;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns item stored at 'itemId'\r\n     * @param itemId : Item index \r\n     */\r\n    function _getItem(uint itemId) \r\n        internal \r\n        view \r\n        returns(Item memory data) \r\n    {\r\n        data = storeFront[itemId];\r\n    }\r\n\r\n    // function _pushItemToStorage(Item memory item) internal {\r\n    //     storeFront.push(item);\r\n    // }\r\n\r\n    // -------> EXTERNAL FUNCTIONS <--------- \r\n\r\n    function getItem(uint itemId) external view returns(Item memory) {\r\n        return _getItem(itemId);\r\n    }\r\n\r\n    function getStoreSize() external view returns(uint) {\r\n        return storeFront.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Buyer-only Utility for editing or make changes to their order.\r\n     * Buyers want to do this in the event of any of the following:\r\n     *          - The Seller rejected their offer.\r\n     *          - No response from the Seller.\r\n     *          - They feel they've not given enough consideration.\r\n     * @param itemId : Item id.\r\n     * @param orderId : Order index.\r\n     * @param newOfferPrice : New offered price.\r\n     * @param newCommitment : Amount given as allowance. This would always be total cost of all selected items.\r\n     */\r\n    function editOrder(\r\n        uint24 newQuantity,\r\n        uint itemId,\r\n        uint orderId,\r\n        uint newOfferPrice,\r\n        uint newCommitment\r\n    )\r\n        external\r\n        whenNotPaused\r\n        onlyRoleStatus(\"Factory: Only Buyer\")\r\n        returns(bool)\r\n    {\r\n        Order memory prev = storeFront[itemId].info.orders[orderId];\r\n        _editQuantity(newQuantity, itemId);\r\n        prev.quantity = newQuantity;\r\n        prev.offerPrice = newOfferPrice;\r\n        prev.commitment = newCommitment;\r\n        storeFront[itemId].info.orders[orderId] = prev;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Parties to trade sign document of completion.\r\n     * @param itemId : Item Id.\r\n     * @param orderId : Order Id.\r\n     * @param party : Party signing i.e Buyer or Seller.\r\n     * On completed signature, trade is finalized and the seller is paid.\r\n     */\r\n    function signConfirmation(\r\n        uint itemId, \r\n        uint orderId, \r\n        address party\r\n    ) \r\n        external \r\n        whenNotPaused\r\n        onlyRoleStatus(\"Factory: Not Permitted\")\r\n        returns(bool)\r\n    {\r\n        Order memory neg = storeFront[itemId].info.orders[orderId];\r\n        if(!neg.firstSigner.isZeroAddress()) {\r\n            /** MsgSender at this point should be the Buyer so we can send callback */\r\n            require(neg.firstSigner != party, \"Party already signed\");\r\n            require(neg.stage == Stage.DELIVERED, \"Goods not delivered\");\r\n            if(ICommon(_msgSender()).getInterfaceId() != BUYER_ID) revert OnlyBuyerCanConfirmDelivery();\r\n            IBuyer(_msgSender()).paySeller(neg.commitment, neg.firstSigner, feeTo);\r\n        } else {\r\n            storeFront[itemId].info.orders[orderId].firstSigner = party;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Cancels order\r\n     * @param itemId : Item index.\r\n     * @param orderId : Order Id.\r\n     */\r\n    function cancelOrder(\r\n        uint itemId, \r\n        uint orderId\r\n    ) \r\n        external \r\n        returns(bool)\r\n    {\r\n        delete storeFront[itemId].info.orders[orderId];\r\n        return true;\r\n    }\r\n\r\n    /**@dev Add item to storeFront\r\n     * @param aip : Parameters struct\r\n     */\r\n    function listNewItem(\r\n        AddItemParam memory aip\r\n    ) \r\n        external \r\n        whenNotPaused\r\n        onlyRoleStatus(\"Factory: Only Seller\")\r\n        returns(Item memory) \r\n    {\r\n        uint itemId = storeFront.length;\r\n        storeFront.push();\r\n        storeFront[itemId].seller = aip.seller;\r\n        storeFront[itemId].meta = ItemMetadata(Category(aip.categorySelector), abi.encode(aip.imageUrI));\r\n        storeFront[itemId].info.quantity = aip.quantity;\r\n        storeFront[itemId].info.id = itemId;\r\n        storeFront[itemId].info.priceLimit = aip.priceLimit;\r\n        storeFront[itemId].info.description = aip.description.toBytes();\r\n        storeFront[itemId].info.location = aip.location.toBytes();\r\n\r\n        return _getItem(itemId);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds new buyer information to item when commitment is made\r\n     * @param order : Order data struct. \r\n     * @param itemId : Item id\r\n     * @param newQuantity : New quantity to set.\r\n     */\r\n    function placeOrder(\r\n        Order memory order, \r\n        uint itemId, \r\n        uint24 newQuantity\r\n    ) \r\n        external \r\n        whenNotPaused\r\n        onlyRoleStatus(\"Factory: Only Buyer\")\r\n        returns(bool) \r\n    {\r\n        _editQuantity(newQuantity, itemId);\r\n        storeFront[itemId].info.orders.push(order);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove item from specified location.\r\n     * This resets the slot to default value.\r\n     * @param itemId : Item id\r\n     */\r\n    function removeItem(uint itemId) \r\n        external \r\n        whenNotPaused \r\n        onlyRoleStatus(\"Factory: Only Seller\")\r\n        returns(bool) \r\n    {\r\n        delete storeFront[itemId];\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Seller moves order by approval or rejection.\r\n     * @param itemId : Item index\r\n     * @param orderId : Order index.\r\n     * @param stage : Stage the order should be e.g Stage.ACCEPTED.\r\n     */\r\n    function moveOrder(\r\n        uint itemId, \r\n        uint orderId,\r\n        Stage stage\r\n    )\r\n        external \r\n        whenNotPaused\r\n        onlyRoleStatus(\"Factory: Only Seller\")\r\n        returns(bool)\r\n    {\r\n        if(orderId >= storeFront[itemId].info.orders.length) revert InvalidOrderId(orderId);\r\n        storeFront[itemId].info.orders[orderId].stage = stage;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Seller change price of an item\r\n     * @param itemId : Item id.\r\n     * @param newPriceLimit : New price to effect .\r\n     */\r\n    function editPriceLimit(\r\n        uint itemId,\r\n        uint newPriceLimit\r\n    ) \r\n        external \r\n        whenNotPaused\r\n        onlyRoleStatus(\"Factory: Only Seller\")\r\n        returns (bool) \r\n    {\r\n        storeFront[itemId].info.priceLimit = newPriceLimit;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Edit Quantity of item that was previously listed by a seller.\r\n     * @param newQuantity : New quatity\r\n     * @param itemId : Item index\r\n     */\r\n    function editQuantity(\r\n        uint24 newQuantity,\r\n        uint itemId\r\n    ) \r\n        external \r\n        whenNotPaused\r\n        onlyRoleStatus(\"Factory: Only Seller\")\r\n        returns (bool) \r\n    {\r\n        _editQuantity(newQuantity, itemId);\r\n        return true;\r\n    }\r\n\r\n\r\n    // -------> VIEW/PURE/PUBLIC FUNCTIONS <---------\r\n\r\n        /**\r\n     * @dev Readonly: Return data from storage\r\n     */\r\n    function getData() public view returns(Item[] memory items) {\r\n        items = storeFront;\r\n        return items;\r\n    }\r\n\r\n}"
    },
    "contracts/implementations/RoleBased.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.20;\r\n\r\nimport { IRoleBased } from \"../interfaces/IRoleBased.sol\";\r\n/**\r\n * @title MsgSender \r\n * @author (Bobeu)\r\n * @notice Non-deployable contract simply returning the calling account.\r\n */\r\nabstract contract MsgSender {\r\n    function _msgSender() internal view returns(address sender) {\r\n        sender = msg.sender;\r\n    }\r\n}\r\n\r\n/**\r\n * @title RoleBased \r\n * @author (Bobeu)\r\n * @notice Standalone contract for managing roleship in kimiko protocol.\r\n */\r\ncontract RoleBased is IRoleBased, MsgSender{\r\n    /**\r\n     * @notice Number of roles.\r\n     */\r\n    uint public rolesCount;\r\n\r\n    /**\r\n     * @notice Addresses with roleship permission.\r\n     */\r\n    \r\n    mapping (address => bool) private _isRoleBased;\r\n\r\n    /**\r\n     * @notice Mapping of rolesCount to addresses.\r\n     * A valid id will return a mapped role.\r\n     */\r\n    mapping (uint => address) public roles;\r\n\r\n    /**\r\n     * @dev Only role is allowed.\r\n     */\r\n    modifier onlyRoleStatus {\r\n        require(_isRoleBased[_msgSender()], \"Oop! Caller is not recognized\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        _setRole(_msgSender(), true);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns role variable.\r\n     */\r\n    function _getRole(uint roleId) \r\n        internal \r\n        view \r\n        returns(address _role) \r\n    {\r\n        _role = roles[roleId];\r\n    }\r\n\r\n    /**\r\n     * @dev Add or remove target address as role.\r\n     * @param target: Target address.\r\n     * @notice 'target' parameter must not be empty.\r\n     */\r\n    function _setRole(\r\n        address target,\r\n        bool add\r\n    ) \r\n        private \r\n    {\r\n        require(target != address(0), \"Simplifi RoleBased: 'target' parameter is empty\");\r\n        add? (_isRoleBased[target] = true, rolesCount ++) : (_isRoleBased[target] = false, rolesCount --);\r\n    }\r\n\r\n    /**\r\n     * @dev Add a new role address\r\n     * @param newRoles: New roles\r\n     * @notice Only address with role permission can add another role.\r\n     */\r\n    function setPermission(\r\n        address[] memory newRoles\r\n    ) \r\n        external\r\n        onlyRoleStatus\r\n        returns(bool) \r\n    {\r\n        bool rt = true;\r\n        for(uint r = 0; r < newRoles.length; r++) {\r\n            _setRole(newRoles[r], rt);\r\n        }\r\n        return rt;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an address as role.\r\n     * @param target: Target address\r\n     * @notice Only address with role permission can remove another role.\r\n     */\r\n    function removeRole(\r\n        address target\r\n    ) \r\n        external\r\n        onlyRoleStatus\r\n        returns(bool) \r\n    {\r\n        _setRole(target, false);\r\n        return true;\r\n    }\r\n    /**\r\n     * @dev An role can renounce their roleship. This however will not leave the\r\n     * contract empty without an role. There must be at least one role left.\r\n     * @notice Only address with role permission can renounce roleship.\r\n     */\r\n    function renounceRole() \r\n        external\r\n        onlyRoleStatus\r\n        returns(bool) \r\n    {\r\n        require(rolesCount > 1, \"At least 2 roles is required for one to leave\"); \r\n        _setRole(_msgSender(), false);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns role variable.\r\n     * Can be called externally by contracts.\r\n     * @param roleId : Owner Id. \r\n     */\r\n    function getRole(\r\n        uint roleId\r\n    ) \r\n        external \r\n        view \r\n        returns(address) \r\n    {\r\n        return _getRole(roleId);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if target is an role.\r\n     * @param target : Target address.\r\n     */\r\n    function hasRole(\r\n        address target\r\n    )\r\n        external\r\n        view \r\n        returns(bool) \r\n    {\r\n        return _isRoleBased[target];\r\n    }\r\n}"
    },
    "contracts/implementations/SellerV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { IFactory } from \"../interfaces/IFactory.sol\";\r\nimport { IBuyer } from \"../interfaces/IBuyer.sol\";\r\nimport { Lib } from \"../Lib.sol\";\r\nimport { Common } from \"./Common.sol\";\r\nimport { ISeller } from \"../interfaces/ISeller.sol\";\r\n\r\ncontract SellerV1 is ISeller, Common {\r\n    using Lib for *;\r\n\r\n    error InvalidStageSelector(uint8);\r\n    error OrderResolved();\r\n    error QuantityShouldBeGreaterThanZero(uint);\r\n\r\n    event ItemAdded(IFactory.Item);\r\n\r\n    address public buyerContract;\r\n\r\n    /**\r\n     * @notice Contract identifier\r\n     * We use it to identify which contract is calling in the factory contract.\r\n     */\r\n    bytes32 immutable interfaceId;\r\n\r\n    /**@dev Only Store owner function\r\n     * @param itemId : item identifier or position in storage \r\n     */\r\n    modifier isStoreOwner(uint itemId) {\r\n        _wrappedFactory().getItem(itemId).seller.equalInAddress(_msgSender(), \"OnlySeller is allowed\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        IFactory _factory, \r\n        IERC20 _uSDT, \r\n        address _buyerContract,\r\n        address _roleManager\r\n    ) \r\n        Common(_factory, _uSDT, _roleManager) \r\n    {\r\n        buyerContract = _buyerContract;\r\n        interfaceId = keccak256(abi.encodePacked(\"SELLER\"));\r\n    }\r\n\r\n    /**\r\n     * @dev Add new Item to storeFront.\r\n     * @param quantity : Quantity of item seller has to sell.\r\n     * @param categorySelector : Main category of item.\r\n     * @param priceLimit : Price per unit of item.\r\n     * @param imageUrI : Image urI i.e IPFS link to uploaded images.\r\n     * @param description : Item description.\r\n     * @param location : Seller's location/address.\r\n     */\r\n    function listItem(\r\n        uint8 quantity,\r\n        uint8 categorySelector,\r\n        uint priceLimit,\r\n        string memory imageUrI,\r\n        string memory description,\r\n        string memory location\r\n    ) \r\n        public \r\n        validateCategoryId(categorySelector) \r\n        returns(bool) \r\n    {\r\n        if(quantity == 0) revert QuantityShouldBeGreaterThanZero(quantity);\r\n        emit ItemAdded(\r\n            _wrappedFactory().listNewItem(\r\n                IFactory.AddItemParam(\r\n                    quantity,\r\n                    categorySelector,\r\n                    priceLimit,\r\n                    imageUrI,\r\n                    description,\r\n                    location,\r\n                    _msgSender()\r\n                )\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Removes item from storefront.\r\n     * @param itemId : Item id\r\n     */\r\n    function removeItem(uint itemId) \r\n        public \r\n        validateIds(itemId, 0, false)\r\n        isStoreOwner(itemId)\r\n        returns(bool) \r\n    {\r\n        IFactory iFact = _wrappedFactory();\r\n        IFactory.Item memory item = iFact.getItem(itemId);\r\n        if(item.info.orders.length > 0) {\r\n            IBuyer(buyerContract).refund(item.info.orders);\r\n        }\r\n        iFact.removeItem(itemId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Move order to the next stage. Example: A seller can accept or\r\n     * reject order but cannot cancel order i.e stage must not equal index 3. \r\n     * Only the buyer can cancel.\r\n     * @param stageSelector : Stage selector should be in number since enums are index-based.\r\n     * @param itemId : Item id/index/position.\r\n     * @param orderId : Order id/index/position.\r\n     */\r\n    function acceptOrder(\r\n        uint8 stageSelector,\r\n        uint itemId, \r\n        uint orderId\r\n    ) \r\n        public \r\n        validateIds(itemId, orderId, true)\r\n        isStoreOwner(itemId)\r\n        returns(bool) \r\n    {\r\n        if(stageSelector >= 6 || stageSelector == 3) revert InvalidStageSelector(stageSelector);\r\n        IFactory iFact = _wrappedFactory();\r\n        IFactory.Item memory item = iFact.getItem(itemId);\r\n        require(orderId < item.info.orders.length, \"Invalid orderId\");\r\n        IFactory.Stage stage = item.info.orders[orderId].stage;\r\n        if(stage == IFactory.Stage.CANCELLED || stage == IFactory.Stage.DELIVERED) revert OrderResolved();\r\n        require(iFact.moveOrder(itemId, orderId, IFactory.Stage(stageSelector)), \"Seller: Operation failed\");\r\n        if(IFactory.Stage(stageSelector) == IFactory.Stage.DELIVERED) {\r\n            iFact.signConfirmation(itemId, orderId, _msgSender());\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Edits price of an item.\r\n     * @param itemId : Item index.\r\n     * @param newPriceLimit : Latest price.\r\n     */\r\n    function editPriceLimit(\r\n        uint itemId,\r\n        uint newPriceLimit\r\n    ) \r\n        external \r\n        validateIds(itemId, 0, false) \r\n        isStoreOwner(itemId) \r\n        returns (bool) \r\n    {\r\n        _wrappedFactory().editPriceLimit(itemId, newPriceLimit);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Edit item quantity\r\n     * @param itemId : Item index.\r\n     * @param newQuantity : New Quantity\r\n     */\r\n    function editQuantity(\r\n        uint24 newQuantity,\r\n        uint itemId\r\n    ) \r\n        public\r\n        validateIds(itemId, 0, false) \r\n        isStoreOwner(itemId) \r\n        returns (bool) \r\n    {\r\n        _wrappedFactory().editQuantity(newQuantity, itemId);\r\n        return true;\r\n    }\r\n\r\n    function getInterfaceId() external view returns(bytes32) {\r\n        return interfaceId;\r\n    }\r\n    \r\n}\r\n"
    },
    "contracts/interfaces/IBuyer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { IFactory } from \"./IFactory.sol\";\r\nimport { ICommon } from \"./ICommon.sol\";\r\n\r\ninterface IBuyer is ICommon {\r\n    function refund(IFactory.Order[] memory) external returns(bool);\r\n    function paySeller(uint amount, address seller, address feeReceiver) external returns(bool);\r\n}"
    },
    "contracts/interfaces/ICommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface ICommon {\r\n    function getInterfaceId() external view returns(bytes32);\r\n}"
    },
    "contracts/interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IFactory {\r\n    enum Category { FASHION, ELECTRONICS, PHONESNTABLETS, FURNITURES, VEHICLES, ANIMALSNPETS, EQUIPMENTSNTOOLS, REPAIRNCONSTRUCTION, SOFTWARES, BABIESNKIDS }\r\n    enum Stage { COMMIT, ACCEPTED, REJECTED, CANCELLED, INTRANSIT, DELIVERED }\r\n\r\n    error UnsupportedCategory(uint8);\r\n    error InvalidItemId();\r\n    error InvalidOrderId(uint negoId);\r\n    error OnlyBuyerCanConfirmDelivery();\r\n    error NotTheRealNegotiator(address);\r\n    error RequestedQuantityExceedAvailableQuantity(uint requested, uint expected);\r\n\r\n    struct Item {\r\n        address seller;\r\n        ItemInfo info;\r\n        ItemMetadata meta;\r\n    }\r\n\r\n    struct ItemInfo {\r\n        uint quantity;\r\n        uint id;\r\n        uint priceLimit;\r\n        bytes description;\r\n        bytes location;\r\n        Order[] orders;\r\n    }\r\n\r\n    struct ItemMetadata {\r\n        Category category;\r\n        bytes uri;\r\n    }\r\n\r\n    struct Order {\r\n        uint24 quantity;\r\n        uint32 date;\r\n        uint offerPrice;\r\n        uint commitment;\r\n        address customer;\r\n        Stage stage;\r\n        Info info;\r\n        address firstSigner;\r\n    }\r\n\r\n    struct Info {\r\n        bytes destination;\r\n        bytes contacts;\r\n    }\r\n\r\n    // -------> PARAMS <-------\r\n\r\n    struct AddItemParam {\r\n        uint8 quantity;\r\n        uint8 categorySelector;\r\n        uint priceLimit;\r\n        string imageUrI;\r\n        string description;\r\n        string location;\r\n        address seller;\r\n    }\r\n\r\n    function listNewItem(AddItemParam memory) external returns(Item memory) ;\r\n    function placeOrder(Order memory order, uint itemId, uint24 newQuantity) external returns(bool);\r\n    function getItem(uint itemId) external view returns(Item memory);\r\n    function editPriceLimit(uint itemId, uint newPriceLimit) external returns (bool);\r\n    function editOrder(\r\n        uint24 newQuantity,\r\n        uint itemId,\r\n        uint orderId,\r\n        uint newOfferPrice,\r\n        uint newCommitment\r\n    )\r\n        external\r\n        returns(bool);\r\n\r\n    function editQuantity(uint24 newQuantity, uint itemId) external returns (bool);\r\n    function getStoreSize() external view returns(uint);\r\n    function removeItem(uint itemId) external returns(bool);\r\n    function cancelOrder(uint itemId, uint orderId) external returns(bool);\r\n    function signConfirmation(uint itemId, uint orderId, address party) external returns(bool);\r\n    function moveOrder(\r\n        uint itemId,\r\n        uint orderId,\r\n        Stage stage\r\n    ) external returns(bool);\r\n\r\n    event ItemRemoved(uint itemId, IERC20 asset);\r\n}"
    },
    "contracts/interfaces/IRoleBased.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.20;\r\n\r\n/**\r\n * @title IRoleBased \r\n * Interface of the RoleBased contract\r\n * @author Bobeu\r\n */\r\ninterface IRoleBased {\r\n    function setPermission(\r\n        address[] memory newRoles\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function removeRole(\r\n        address target\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function renounceRole() \r\n        external\r\n        returns(bool);\r\n\r\n    function getRole(\r\n        uint ownerId\r\n    ) \r\n        external \r\n        view \r\n        returns(address);\r\n\r\n    function hasRole(\r\n        address target\r\n    )\r\n        external\r\n        view \r\n        returns(bool);\r\n}"
    },
    "contracts/interfaces/ISeller.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { ICommon } from \"./ICommon.sol\";\r\n\r\ninterface ISeller is ICommon {}"
    },
    "contracts/Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nlibrary Lib {\r\n    function isZeroAddress(address target) internal pure returns(bool _isZero) {\r\n        _isZero = target == address(0);\r\n    }\r\n\r\n    function notEqualInAddress(address a, address b, string memory errorMessage) internal pure {\r\n        require( a != b, errorMessage);\r\n    }\r\n\r\n    function equalInAddress(address a, address b, string memory errorMessage)internal pure {\r\n        require( a == b, errorMessage);\r\n    }\r\n\r\n    function assertEqual(uint a, uint b, string memory errorMessage) internal pure {\r\n        require( a == b, errorMessage);\r\n    }\r\n\r\n    function assertGThan(uint a, uint b, string memory errorMessage) internal pure {\r\n        require( a > b, errorMessage);\r\n    }\r\n\r\n    function assertLThan(uint a, uint b, string memory errorMessage) internal pure {\r\n        require( a < b, errorMessage);\r\n    }\r\n\r\n    function assertGThanOrEqual(uint a, uint b, string memory errorMessage) internal pure {\r\n        require( a >= b, errorMessage);\r\n    }\r\n\r\n    function toBytes(string memory str) internal pure returns(bytes memory) {\r\n        return abi.encode(str);\r\n    }\r\n\r\n    /**\r\n     * Percentage base\r\n     */\r\n    function _getBase() internal pure returns(uint16 base) {\r\n        base = 10000;\r\n    }\r\n\r\n    /**\r\n        @dev Computes platform fee.\r\n        @param makerRate : The amount of fee (in %) charged by the platform\r\n            Note : Raw rate must multiply by 100 to get the expected value i.e\r\n            if maker rate is 0.1%, it should be parsed as 0.1 * 100 = 10.\r\n            See `_getPercentage()`.\r\n        @param amount should be in decimals.\r\n    */\r\n    function computeFee(\r\n        uint amount, \r\n        uint16 makerRate\r\n    ) \r\n        internal \r\n        pure \r\n        returns (uint mFee) \r\n    {\r\n        mFee = _getPercentage(amount, makerRate);\r\n    }\r\n\r\n    /**     @dev Calculation of percentage.\r\n        *   This is how we calculate percentage to arrive at expected value with \r\n        *   good precision.\r\n        *   We chose a base value (numerator as 10000) repesenting a 100% of input value. This means if Alice wish to set \r\n        *   her interest rate to 0.05%, she only need to multiply it by 100 i.e 0.05 * 100 = 5. Her input will be 5. \r\n        *   Since Solidity do not accept decimals as input, in our context, the minimum value to parse is '0' indicating \r\n        *   zero interest rate. If the platform wish to set interest at least, the minimum value will be 1 reprensenting 0.01%.\r\n        *   The minimum interest rate to set is 0.01% if interest must be set at least.\r\n        *   @notice To reiterate, raw interest must be multiplied by 100 before giving as input. \r\n        *   @param principal : The principal value on which the interest is based. Value should be in decimals.\r\n        *   @param interest : Interest rate. \r\n        *   \r\n        *   Rules\r\n        *   -----\r\n        *   - Principal cannot be less than base.\r\n        *   - Interest cannot be greater than (2 ^ 16) - 1\r\n    */\r\n    function _getPercentage(\r\n        uint principal, \r\n        uint16 interest\r\n    )\r\n        internal \r\n        pure \r\n        returns (uint _return) \r\n    {\r\n        uint16 base = _getBase(); \r\n        if(interest == 0 || principal == 0) return 0;\r\n        assertLThan(interest, type(uint16).max, \"Interest overflow\");\r\n        assertGThan(principal, base, \"Principal should be greater than 10000\");\r\n        unchecked {\r\n            _return = (principal * interest) / base;\r\n        }\r\n    }\r\n}"
    },
    "contracts/Lock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.9;\r\n\r\n// Uncomment this line to use console.log\r\n// import \"hardhat/console.sol\";\r\n\r\ncontract Lock {\r\n    uint public unlockTime;\r\n    address payable public owner;\r\n\r\n    event Withdrawal(uint amount, uint when);\r\n\r\n    constructor(uint _unlockTime) payable {\r\n        require(\r\n            block.timestamp < _unlockTime,\r\n            \"Unlock time should be in the future\"\r\n        );\r\n\r\n        unlockTime = _unlockTime;\r\n        owner = payable(msg.sender);\r\n    }\r\n\r\n    function withdraw() public {\r\n        // Uncomment this line, and the import of \"hardhat/console.sol\", to print a log in your terminal\r\n        // console.log(\"Unlock time is %o and block timestamp is %o\", unlockTime, block.timestamp);\r\n\r\n        require(block.timestamp >= unlockTime, \"You can't withdraw yet\");\r\n        require(msg.sender == owner, \"You aren't the owner\");\r\n\r\n        emit Withdrawal(address(this).balance, block.timestamp);\r\n\r\n        owner.transfer(address(this).balance);\r\n    }\r\n}\r\n"
    },
    "contracts/testToken/TestUSDT.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract TestUSDT is ERC20 {\r\n    address public admin;\r\n    constructor() ERC20(\"TestUSDT\", \"TUSDT\") {\r\n        admin = msg.sender;\r\n        uint mintable = 200000 * (10**18);\r\n        _mint(msg.sender, mintable);\r\n    } \r\n\r\n    function mint(address to) public returns(bool) {\r\n        require(msg.sender == admin, \"Not permitted\");\r\n        uint mintable = 400000 * (10**18);\r\n        _mint(to, mintable);\r\n        return true;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "byzantium",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}