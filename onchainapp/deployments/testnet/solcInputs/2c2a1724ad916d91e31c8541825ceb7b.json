{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/abstracts/OnlyRoleStatus.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.20;\r\n\r\nimport { MsgSender, RoleBased } from \"../implementations/RoleBased.sol\";\r\nimport { IRoleBased } from \"../interfaces/IRoleBased.sol\";\r\n\r\nabstract contract OnlyRoleStatus is MsgSender {\r\n    address public roleManager;\r\n\r\n    constructor(address _roleManager)\r\n    {\r\n        _setRoleManager(_roleManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Caller must have owner role before execeution can proceed.\r\n     * The 'errorMessage' argument can be used to return error specific to \r\n     * a context e.g function call. \r\n     * @param errorMessage : Custom error message\r\n     */\r\n    modifier onlyRoleStatus(string memory errorMessage) {\r\n        address mgr = roleManager;\r\n        require(mgr != address(0), \"OnlyRoleStatus: Manager not set\");\r\n        require(IRoleBased(mgr).hasRole(_msgSender()), errorMessage);\r\n        _;\r\n    }\r\n\r\n    function _setRoleManager(\r\n        address newManager\r\n    )\r\n        private\r\n    {\r\n        roleManager = newManager;\r\n    }\r\n\r\n    /**\r\n     * Set RoleManager\r\n     * @param newManager : New manager address\r\n     */\r\n    function setRoleManager(\r\n        address newManager\r\n    )\r\n        public\r\n        onlyRoleStatus(\"OnlyRoleStatus: Not permitted\")\r\n        returns(bool)\r\n    {\r\n        _setRoleManager(newManager);\r\n        return true;\r\n    }\r\n}"
    },
    "contracts/abstracts/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.20;\r\n\r\nimport { OnlyRoleStatus } from \"./OnlyRoleStatus.sol\";\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n * \r\n * We use part of the Openzeppelin Pausable contract to supplement our strategy.\r\n * Thanks to the OZ team.\r\n */\r\nabstract contract Pausable is OnlyRoleStatus {\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is paused.\r\n     */\r\n    error EnforcedPause();\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is not paused.\r\n     */\r\n    error ExpectedPause();\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor(\r\n        address _roleManager\r\n    ) OnlyRoleStatus(_roleManager) {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view {\r\n        if (paused()) {\r\n            revert EnforcedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        if (!paused()) {\r\n            revert ExpectedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     * Only owner role can call.\r\n     * - The contract must not be paused.\r\n     */\r\n    function pause() \r\n        public \r\n        onlyRoleStatus(\"Pausable: OnlyRoleStatus can pause\") \r\n        whenNotPaused \r\n    {\r\n        _paused = true; \r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     * - Only owner role can call.\r\n     * - The contract must be paused.\r\n     */\r\n    function unpause() \r\n        public \r\n        onlyRoleStatus(\"Pausable: OnlyRoleStatus can unpause\") \r\n        whenPaused \r\n    {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n"
    },
    "contracts/implementations/Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IFactory } from \"../interfaces/IFactory.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { Lib } from \"../Lib.sol\";\r\nimport { ICommon } from \"../interfaces/ICommon.sol\";\r\nimport { IBuyer } from \"../interfaces/IBuyer.sol\";\r\nimport { Pausable } from \"../abstracts/Pausable.sol\";\r\n\r\ncontract Factory is IFactory, Pausable {\r\n    using Lib for *;\r\n\r\n    // Stablecoin address\r\n    IERC20 public uSDT;\r\n\r\n    // Fee receiver\r\n    address public feeTo;\r\n\r\n    bytes32 public constant BUYER_ID = keccak256(abi.encodePacked(\"BUYER\"));\r\n    bytes32 public constant SELLER_ID = keccak256(abi.encodePacked(\"SELLER\"));\r\n\r\n    /**\r\n     * @dev Array of storeItems\r\n     * Note: For the purpose of testing and to quickly share data\r\n     * to the frontend, we employ this pattern of storage. As the array \r\n     * grow in size, it may have huge impact on gas cost hence we plan to \r\n     * switch to a more cheaper storage type.\r\n     */ \r\n    Item[] private storeFront;\r\n\r\n    constructor(\r\n        address _feeTo, \r\n        address _roleManager\r\n    ) \r\n        Pausable(_roleManager) \r\n    {\r\n        _feeTo.notEqualInAddress(address(0), \"FeeReceiver is zero address\");\r\n        require(_feeTo != address(0), \"Invalid FeeReceiver\");\r\n        feeTo = _feeTo;\r\n    }\r\n\r\n    // -------> INTERNAL FUNCTIONS <---------\r\n\r\n    /**\r\n     * @dev Only store owner function: Change price limit i.e lower price an item can be sold\r\n     * @param itemId : Required: Item reference Id.\r\n     * @param newQuantity : Required: New available quantity.\r\n    */\r\n    function _editQuantity(\r\n        uint96 newQuantity,\r\n        uint itemId\r\n    ) internal {\r\n        storeFront[itemId].info.quantity = newQuantity;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns item stored at 'itemId'\r\n     * @param itemId : Item index \r\n     */\r\n    function _getItem(uint itemId) \r\n        internal \r\n        view \r\n        returns(Item memory data) \r\n    {\r\n        data = storeFront[itemId];\r\n    }\r\n\r\n    // function _pushItemToStorage(Item memory item) internal {\r\n    //     storeFront.push(item);\r\n    // }\r\n\r\n    // -------> EXTERNAL FUNCTIONS <--------- \r\n\r\n    function getItem(uint itemId) external view returns(Item memory) {\r\n        return _getItem(itemId);\r\n    }\r\n\r\n    function getStoreSize() external view returns(uint) {\r\n        return storeFront.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Buyer-only Utility for editing or make changes to their order.\r\n     * Buyers want to do this in the event of any of the following:\r\n     *          - The Seller rejected their offer.\r\n     *          - No response from the Seller.\r\n     *          - They feel they've not given enough consideration.\r\n     * @param itemId : Item id.\r\n     * @param orderId : Order index.\r\n     * @param newOfferPrice : New offered price.\r\n     * @param newCommitment : Amount given as allowance. This would always be total cost of all selected items.\r\n     */\r\n    function editOrder(\r\n        uint24 newQuantity,\r\n        uint itemId,\r\n        uint orderId,\r\n        uint newOfferPrice,\r\n        uint newCommitment\r\n    )\r\n        external\r\n        whenNotPaused\r\n        onlyRoleStatus(\"Factory: Only Buyer\")\r\n        returns(bool)\r\n    {\r\n        Order memory prev = storeFront[itemId].info.orders[orderId];\r\n        _editQuantity(newQuantity, itemId);\r\n        prev.quantity = newQuantity;\r\n        prev.offerPrice = newOfferPrice;\r\n        prev.commitment = newCommitment;\r\n        storeFront[itemId].info.orders[orderId] = prev;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Parties to trade sign document of completion.\r\n     * @param itemId : Item Id.\r\n     * @param orderId : Order Id.\r\n     * @param party : Party signing i.e Buyer or Seller.\r\n     * On completed signature, trade is finalized and the seller is paid.\r\n     */\r\n    function signConfirmation(\r\n        uint itemId, \r\n        uint orderId, \r\n        address party\r\n    ) \r\n        external \r\n        whenNotPaused\r\n        onlyRoleStatus(\"Factory: Not Permitted\")\r\n        returns(bool)\r\n    {\r\n        Order memory neg = storeFront[itemId].info.orders[orderId];\r\n        if(!neg.firstSigner.isZeroAddress()) {\r\n            /** MsgSender at this point should be the Buyer so we can send callback */\r\n            require(neg.firstSigner != party, \"Party already signed\");\r\n            require(neg.stage == Stage.DELIVERED, \"Goods not delivered\");\r\n            if(ICommon(_msgSender()).getInterfaceId() != BUYER_ID) revert OnlyBuyerCanConfirmDelivery();\r\n            IBuyer(_msgSender()).paySeller(neg.commitment, neg.firstSigner, feeTo);\r\n        } else {\r\n            storeFront[itemId].info.orders[orderId].firstSigner = party;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Cancels order\r\n     * @param itemId : Item index.\r\n     * @param orderId : Order Id.\r\n     */\r\n    function cancelOrder(\r\n        uint itemId, \r\n        uint orderId\r\n    ) \r\n        external \r\n        returns(bool)\r\n    {\r\n        storeFront[itemId].info.orders[orderId].stage = Stage.CANCELLED;\r\n        return true;\r\n    }\r\n\r\n    /**@dev Add item to storeFront\r\n     * @param aip : Parameters struct\r\n     */\r\n    function listNewItem(\r\n        AddItemParam memory aip\r\n    ) \r\n        external \r\n        whenNotPaused\r\n        onlyRoleStatus(\"Factory: Only Seller\")\r\n        returns(Item memory) \r\n    {\r\n        uint itemId = storeFront.length;\r\n        storeFront.push();\r\n        storeFront[itemId].seller = aip.seller;\r\n        storeFront[itemId].meta = ItemMetadata(Category(aip.categorySelector), abi.encode(aip.imageUrI));\r\n        storeFront[itemId].info.quantity = aip.quantity;\r\n        storeFront[itemId].info.id = itemId;\r\n        storeFront[itemId].info.priceLimit = aip.priceLimit;\r\n        storeFront[itemId].info.description = aip.description.toBytes();\r\n        storeFront[itemId].info.location = aip.location.toBytes();\r\n\r\n        return _getItem(itemId);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds new buyer information to item when commitment is made\r\n     * @param order : Order data struct. \r\n     * @param itemId : Item id\r\n     * @param newQuantity : New quantity to set.\r\n     */\r\n    function placeOrder(\r\n        Order memory order, \r\n        uint itemId, \r\n        uint24 newQuantity\r\n    ) \r\n        external \r\n        whenNotPaused\r\n        onlyRoleStatus(\"Factory: Only Buyer\")\r\n        returns(bool) \r\n    {\r\n        _editQuantity(newQuantity, itemId);\r\n        storeFront[itemId].info.orders.push(order);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove item from specified location.\r\n     * This resets the slot to default value.\r\n     * @param itemId : Item id\r\n     */\r\n    function removeItem(uint itemId) \r\n        external \r\n        whenNotPaused \r\n        onlyRoleStatus(\"Factory: Only Seller\")\r\n        returns(bool) \r\n    {\r\n        delete storeFront[itemId];\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Seller moves order by approval or rejection.\r\n     * @param itemId : Item index\r\n     * @param orderId : Order index.\r\n     * @param stage : Stage the order should be e.g Stage.ACCEPTED.\r\n     */\r\n    function moveOrder(\r\n        uint itemId, \r\n        uint orderId,\r\n        Stage stage\r\n    )\r\n        external \r\n        whenNotPaused\r\n        onlyRoleStatus(\"Factory: Only Seller\")\r\n        returns(bool)\r\n    {\r\n        if(orderId >= storeFront[itemId].info.orders.length) revert InvalidOrderId(orderId);\r\n        storeFront[itemId].info.orders[orderId].stage = stage;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Seller change price of an item\r\n     * @param itemId : Item id.\r\n     * @param newPriceLimit : New price to effect .\r\n     */\r\n    function editPriceLimit(\r\n        uint itemId,\r\n        uint newPriceLimit\r\n    ) \r\n        external \r\n        whenNotPaused\r\n        onlyRoleStatus(\"Factory: Only Seller\")\r\n        returns (bool) \r\n    {\r\n        storeFront[itemId].info.priceLimit = newPriceLimit;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Edit Quantity of item that was previously listed by a seller.\r\n     * @param newQuantity : New quatity\r\n     * @param itemId : Item index\r\n     */\r\n    function editQuantity(\r\n        uint24 newQuantity,\r\n        uint itemId\r\n    ) \r\n        external \r\n        whenNotPaused\r\n        onlyRoleStatus(\"Factory: Only Seller\")\r\n        returns (bool) \r\n    {\r\n        _editQuantity(newQuantity, itemId);\r\n        return true;\r\n    }\r\n\r\n\r\n    // -------> VIEW/PURE/PUBLIC FUNCTIONS <---------\r\n\r\n        /**\r\n     * @dev Readonly: Return data from storage\r\n     */\r\n    function getData() public view returns(Item[] memory items) {\r\n        items = storeFront;\r\n        return items;\r\n    }\r\n\r\n}"
    },
    "contracts/implementations/RoleBased.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.20;\r\n\r\nimport { IRoleBased } from \"../interfaces/IRoleBased.sol\";\r\n/**\r\n * @title MsgSender \r\n * @author (Bobeu)\r\n * @notice Non-deployable contract simply returning the calling account.\r\n */\r\nabstract contract MsgSender {\r\n    function _msgSender() internal view returns(address sender) {\r\n        sender = msg.sender;\r\n    }\r\n}\r\n\r\n/**\r\n * @title RoleBased \r\n * @author (Bobeu)\r\n * @notice Standalone contract for managing roleship in kimiko protocol.\r\n */\r\ncontract RoleBased is IRoleBased, MsgSender{\r\n    /**\r\n     * @notice Number of roles.\r\n     */\r\n    uint public rolesCount;\r\n\r\n    /**\r\n     * @notice Addresses with roleship permission.\r\n     */\r\n    \r\n    mapping (address => bool) private _isRoleBased;\r\n\r\n    /**\r\n     * @notice Mapping of rolesCount to addresses.\r\n     * A valid id will return a mapped role.\r\n     */\r\n    mapping (uint => address) public roles;\r\n\r\n    /**\r\n     * @dev Only role is allowed.\r\n     */\r\n    modifier onlyRoleStatus {\r\n        require(_isRoleBased[_msgSender()], \"Oop! Caller is not recognized\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        _setRole(_msgSender(), true);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns role variable.\r\n     */\r\n    function _getRole(uint roleId) \r\n        internal \r\n        view \r\n        returns(address _role) \r\n    {\r\n        _role = roles[roleId];\r\n    }\r\n\r\n    /**\r\n     * @dev Add or remove target address as role.\r\n     * @param target: Target address.\r\n     * @notice 'target' parameter must not be empty.\r\n     */\r\n    function _setRole(\r\n        address target,\r\n        bool add\r\n    ) \r\n        private \r\n    {\r\n        require(target != address(0), \"Simplifi RoleBased: 'target' parameter is empty\");\r\n        add? (_isRoleBased[target] = true, rolesCount ++) : (_isRoleBased[target] = false, rolesCount --);\r\n    }\r\n\r\n    /**\r\n     * @dev Add a new role address\r\n     * @param newRoles: New roles\r\n     * @notice Only address with role permission can add another role.\r\n     */\r\n    function setPermission(\r\n        address[] memory newRoles\r\n    ) \r\n        external\r\n        onlyRoleStatus\r\n        returns(bool) \r\n    {\r\n        bool rt = true;\r\n        for(uint r = 0; r < newRoles.length; r++) {\r\n            _setRole(newRoles[r], rt);\r\n        }\r\n        return rt;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an address as role.\r\n     * @param target: Target address\r\n     * @notice Only address with role permission can remove another role.\r\n     */\r\n    function removeRole(\r\n        address target\r\n    ) \r\n        external\r\n        onlyRoleStatus\r\n        returns(bool) \r\n    {\r\n        _setRole(target, false);\r\n        return true;\r\n    }\r\n    /**\r\n     * @dev An role can renounce their roleship. This however will not leave the\r\n     * contract empty without an role. There must be at least one role left.\r\n     * @notice Only address with role permission can renounce roleship.\r\n     */\r\n    function renounceRole() \r\n        external\r\n        onlyRoleStatus\r\n        returns(bool) \r\n    {\r\n        require(rolesCount > 1, \"At least 2 roles is required for one to leave\"); \r\n        _setRole(_msgSender(), false);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns role variable.\r\n     * Can be called externally by contracts.\r\n     * @param roleId : Owner Id. \r\n     */\r\n    function getRole(\r\n        uint roleId\r\n    ) \r\n        external \r\n        view \r\n        returns(address) \r\n    {\r\n        return _getRole(roleId);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if target is an role.\r\n     * @param target : Target address.\r\n     */\r\n    function hasRole(\r\n        address target\r\n    )\r\n        external\r\n        view \r\n        returns(bool) \r\n    {\r\n        return _isRoleBased[target];\r\n    }\r\n}"
    },
    "contracts/interfaces/IBuyer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { IFactory } from \"./IFactory.sol\";\r\nimport { ICommon } from \"./ICommon.sol\";\r\n\r\ninterface IBuyer is ICommon {\r\n    function refund(IFactory.Order[] memory) external returns(bool);\r\n    function paySeller(uint amount, address seller, address feeReceiver) external returns(bool);\r\n}"
    },
    "contracts/interfaces/ICommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface ICommon {\r\n    function getInterfaceId() external view returns(bytes32);\r\n}"
    },
    "contracts/interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IFactory {\r\n    enum Category { FASHION, ELECTRONICS, PHONESNTABLETS, FURNITURES, VEHICLES, ANIMALSNPETS, EQUIPMENTSNTOOLS, REPAIRNCONSTRUCTION, SOFTWARES, BABIESNKIDS }\r\n    enum Stage { COMMIT, ACCEPTED, REJECTED, CANCELLED, INTRANSIT, DELIVERED }\r\n\r\n    error UnsupportedCategory(uint8);\r\n    error InvalidItemId();\r\n    error InvalidOrderId(uint negoId);\r\n    error OnlyBuyerCanConfirmDelivery();\r\n    error NotTheRealNegotiator(address);\r\n    error RequestedQuantityExceedAvailableQuantity(uint requested, uint expected);\r\n\r\n    struct Item {\r\n        address seller;\r\n        ItemInfo info;\r\n        ItemMetadata meta;\r\n    }\r\n\r\n    struct ItemInfo {\r\n        uint quantity;\r\n        uint id;\r\n        uint priceLimit;\r\n        bytes description;\r\n        bytes location;\r\n        Order[] orders;\r\n    }\r\n\r\n    struct ItemMetadata {\r\n        Category category;\r\n        bytes uri;\r\n    }\r\n\r\n    struct Order {\r\n        uint24 quantity;\r\n        uint32 date;\r\n        uint offerPrice;\r\n        uint commitment;\r\n        address customer;\r\n        Stage stage;\r\n        Info info;\r\n        address firstSigner;\r\n    }\r\n\r\n    struct Info {\r\n        bytes destination;\r\n        bytes contacts;\r\n    }\r\n\r\n    // -------> PARAMS <-------\r\n\r\n    struct AddItemParam {\r\n        uint8 quantity;\r\n        uint8 categorySelector;\r\n        uint priceLimit;\r\n        string imageUrI;\r\n        string description;\r\n        string location;\r\n        address seller;\r\n    }\r\n\r\n    function listNewItem(AddItemParam memory) external returns(Item memory) ;\r\n    function placeOrder(Order memory order, uint itemId, uint24 newQuantity) external returns(bool);\r\n    function getItem(uint itemId) external view returns(Item memory);\r\n    function editPriceLimit(uint itemId, uint newPriceLimit) external returns (bool);\r\n    function editOrder(\r\n        uint24 newQuantity,\r\n        uint itemId,\r\n        uint orderId,\r\n        uint newOfferPrice,\r\n        uint newCommitment\r\n    )\r\n        external\r\n        returns(bool);\r\n\r\n    function editQuantity(uint24 newQuantity, uint itemId) external returns (bool);\r\n    function getStoreSize() external view returns(uint);\r\n    function removeItem(uint itemId) external returns(bool);\r\n    function cancelOrder(uint itemId, uint orderId) external returns(bool);\r\n    function signConfirmation(uint itemId, uint orderId, address party) external returns(bool);\r\n    function moveOrder(\r\n        uint itemId,\r\n        uint orderId,\r\n        Stage stage\r\n    ) external returns(bool);\r\n\r\n    event ItemRemoved(uint itemId, IERC20 asset);\r\n}"
    },
    "contracts/interfaces/IRoleBased.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.20;\r\n\r\n/**\r\n * @title IRoleBased \r\n * Interface of the RoleBased contract\r\n * @author Bobeu\r\n */\r\ninterface IRoleBased {\r\n    function setPermission(\r\n        address[] memory newRoles\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function removeRole(\r\n        address target\r\n    ) \r\n        external\r\n        returns(bool);\r\n\r\n    function renounceRole() \r\n        external\r\n        returns(bool);\r\n\r\n    function getRole(\r\n        uint ownerId\r\n    ) \r\n        external \r\n        view \r\n        returns(address);\r\n\r\n    function hasRole(\r\n        address target\r\n    )\r\n        external\r\n        view \r\n        returns(bool);\r\n}"
    },
    "contracts/Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nlibrary Lib {\r\n    function isZeroAddress(address target) internal pure returns(bool _isZero) {\r\n        _isZero = target == address(0);\r\n    }\r\n\r\n    function notEqualInAddress(address a, address b, string memory errorMessage) internal pure {\r\n        require( a != b, errorMessage);\r\n    }\r\n\r\n    function equalInAddress(address a, address b, string memory errorMessage)internal pure {\r\n        require( a == b, errorMessage);\r\n    }\r\n\r\n    function assertEqual(uint a, uint b, string memory errorMessage) internal pure {\r\n        require( a == b, errorMessage);\r\n    }\r\n\r\n    function assertGThan(uint a, uint b, string memory errorMessage) internal pure {\r\n        require( a > b, errorMessage);\r\n    }\r\n\r\n    function assertLThan(uint a, uint b, string memory errorMessage) internal pure {\r\n        require( a < b, errorMessage);\r\n    }\r\n\r\n    function assertGThanOrEqual(uint a, uint b, string memory errorMessage) internal pure {\r\n        require( a >= b, errorMessage);\r\n    }\r\n\r\n    function toBytes(string memory str) internal pure returns(bytes memory) {\r\n        return abi.encode(str);\r\n    }\r\n\r\n    /**\r\n     * Percentage base\r\n     */\r\n    function _getBase() internal pure returns(uint16 base) {\r\n        base = 10000;\r\n    }\r\n\r\n    /**\r\n        @dev Computes platform fee.\r\n        @param makerRate : The amount of fee (in %) charged by the platform\r\n            Note : Raw rate must multiply by 100 to get the expected value i.e\r\n            if maker rate is 0.1%, it should be parsed as 0.1 * 100 = 10.\r\n            See `_getPercentage()`.\r\n        @param amount should be in decimals.\r\n    */\r\n    function computeFee(\r\n        uint amount, \r\n        uint16 makerRate\r\n    ) \r\n        internal \r\n        pure \r\n        returns (uint mFee) \r\n    {\r\n        mFee = _getPercentage(amount, makerRate);\r\n    }\r\n\r\n    /**     @dev Calculation of percentage.\r\n        *   This is how we calculate percentage to arrive at expected value with \r\n        *   good precision.\r\n        *   We chose a base value (numerator as 10000) repesenting a 100% of input value. This means if Alice wish to set \r\n        *   her interest rate to 0.05%, she only need to multiply it by 100 i.e 0.05 * 100 = 5. Her input will be 5. \r\n        *   Since Solidity do not accept decimals as input, in our context, the minimum value to parse is '0' indicating \r\n        *   zero interest rate. If the platform wish to set interest at least, the minimum value will be 1 reprensenting 0.01%.\r\n        *   The minimum interest rate to set is 0.01% if interest must be set at least.\r\n        *   @notice To reiterate, raw interest must be multiplied by 100 before giving as input. \r\n        *   @param principal : The principal value on which the interest is based. Value should be in decimals.\r\n        *   @param interest : Interest rate. \r\n        *   \r\n        *   Rules\r\n        *   -----\r\n        *   - Principal cannot be less than base.\r\n        *   - Interest cannot be greater than (2 ^ 16) - 1\r\n    */\r\n    function _getPercentage(\r\n        uint principal, \r\n        uint16 interest\r\n    )\r\n        internal \r\n        pure \r\n        returns (uint _return) \r\n    {\r\n        uint16 base = _getBase(); \r\n        if(interest == 0 || principal == 0) return 0;\r\n        assertLThan(interest, type(uint16).max, \"Interest overflow\");\r\n        assertGThan(principal, base, \"Principal should be greater than 10000\");\r\n        unchecked {\r\n            _return = (principal * interest) / base;\r\n        }\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "byzantium",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}